# P1219 [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。

## 输入格式

一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。

## 输出格式

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 输入输出样例 #1

### 输入 #1

```
6
```

### 输出 #1

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5

# Solution:
这段代码是用回溯算法来解**N皇后问题**的。简单来说，就是要在一个`n x n`的棋盘上放置`n`个皇后，要求这些皇后不能互相攻击，也就是不能在同一行、同一列或者同一条对角线。

### 代码的基本思路：

1.  **回溯 + 递归**：
    
    *   代码从第1行开始，每一行尝试把一个皇后放在不同的列，递归地去放置下一行的皇后。这样一层一层地递归下去，直到所有的行都放好皇后。
        
    *   如果某一行放不下皇后（因为有冲突），它会“回溯”到上一行，重新尝试放置。
        
2.  **怎么判断皇后能不能放**：
    
    *   为了避免检查每一列和每条对角线有没有皇后，我们使用了三个数组：
        
        *   `check1[i]`：标记第`i`列是否已经放了皇后。
            
        *   `check2[line + i]`：标记从左上到右下的对角线是否被占用了。
            
        *   `check3[line - i + n]`：标记从右上到左下的对角线是否被占用了。
            
    *   每次递归时，都会先检查这三个数组，看当前皇后能不能放。
        
3.  **提前结束**：
    
    *   代码里有个`sum`变量来记录找到的解的个数。一旦找到了超过3个解，代码就会停止继续搜索，避免浪费时间。
        
4.  **递归的停止条件**：
    
    *   当`line > n`时，说明已经把所有的皇后都放好了，这时就输出这个解，并增加解的计数。如果解的数量已经超过3个，就结束搜索。
        

### 代码的细节：

1.  **`dfs`函数**：这个函数是递归的核心，它的作用是从当前的`line`行开始，尝试放置皇后，检查是否符合规则，然后递归到下一行。如果放置成功，就继续尝试下一行。如果放置失败（有冲突），则回到上一行，重新尝试。
    
2.  **数组`check1`、`check2`、`check3`**：
    
    *   `check1`用于检查列，`check2`和`check3`则分别用于检查两条对角线。通过这些数组，代码能够在每一步判断是否可以放置皇后，避免了遍历所有位置的麻烦。
        
3.  **找到解后的输出**：当找到一个解时，程序会打印出皇后的位置（即第`i`行放在哪一列）。它会打印出前3个解，之后就停止输出。
    

### 代码的优化：

*   **提前结束**：通过`sum`来控制解的输出数量，最多输出3个解后就停止搜索，这样能减少不必要的计算。
    
*   **三条检查线**：使用了三个布尔数组来高效地判断每列和两条对角线是否被占用，这样就避免了重复检查。
    

### 总结：

这段代码通过回溯法解决了N皇后问题，利用三个布尔数组来确保每次放置皇后时符合规则，递归回溯使得代码能遍历所有可能的解。通过提前停止计算，它在找到前三个解后就不会继续搜索，确保了效率。
