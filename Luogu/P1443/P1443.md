# P1443 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 输入输出样例 #1

### 输入 #1

```
3 3 1 1
```

### 输出 #1

```
0    3    2    
3    -1   1    
2    1    4
```

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

# Solution
## 问题描述

该程序解决了一个棋盘上骑士最短路径问题。给定一个大小为 `n` 行 `m` 列的棋盘，和骑士的起始位置 `(sx, sy)`，程序通过广度优先搜索（BFS）算法，计算从起始位置出发到达棋盘上每个位置的最短步数。

## 主要思路

### 骑士的移动规则

骑士在棋盘上可以做8种不同的跳跃动作，分别是：

- 向上跳两步、向左跳一步；
- 向上跳两步、向右跳一步；
- 向右跳两步、向上跳一步；
- 向右跳两步、向下跳一步；
- 向下跳两步、向右跳一步；
- 向下跳两步、向左跳一步；
- 向左跳两步、向下跳一步；
- 向左跳两步、向上跳一步。

### 广度优先搜索（BFS）

由于每个位置到起始位置的步数是一样的，我们可以使用广度优先搜索来求解最短路径。BFS 能够在无权图中找到从起始节点到其他节点的最短路径。

### 数组记录

通过一个二维数组 `ans` 来记录每个位置的最短步数，初始时，所有位置都设为 `-1`，表示不可达。开始时，将起始位置设为 `0`，表示从起始位置出发的步数为 `0`。

### 队列使用

BFS 算法通过队列来进行层级遍历，依次检查骑士能够到达的相邻位置，并将未访问过的位置加入队列继续探索。

### 边界检查

在探索相邻位置时，必须确保新位置在棋盘的有效范围内，并且该位置还未被访问过。

## 步骤

1. **初始化**：创建一个二维数组 `ans`，将所有元素初始化为 `-1`，表示所有位置还没有被访问。
2. **输入**：读取棋盘的行数 `n`、列数 `m` 和骑士的起始位置 `(sx, sy)`，并将其转换为0基索引。
3. **BFS 搜索**：从起始位置 `(sx, sy)` 开始，利用广度优先搜索探索所有可达的位置，更新每个位置的最短步数。
4. **输出结果**：输出每个位置到起始位置的最短步数，如果某个位置不可达，则输出 `-1`。

## 输出

程序会输出一个 `n x m` 的二维数组，其中每个元素表示从起始位置到该位置的最短步数。如果某个位置不可达，则显示 `-1`。

例如，在一个 5x5 的棋盘上，若骑士从 `(1, 1)`（1基索引）出发，程序输出的最短路径表格如下：

0 3 4 3 4
3 2 3 4 5
4 3 2 3 4
3 4 3 4 5
4 5 4 5 6


其中，数字表示从起始位置到每个位置所需的最短步数。如果某个位置不可达，则显示 `-1`。

## 复杂度分析

- **时间复杂度**：由于 BFS 遍历了棋盘上的每一个位置，每个位置最多被访问一次，因此时间复杂度为 `O(n * m)`，其中 `n` 和 `m` 是棋盘的行数和列数。
- **空间复杂度**：BFS 需要一个队列来存储待访问的节点，因此空间复杂度为 `O(n * m)`，此外还需要一个二维数组 `ans` 来记录最短步数。
